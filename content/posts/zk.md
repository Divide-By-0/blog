---
title: "An Opinionated Overview of ZK Tooling and Proof Systems Right Now"
date: 2023-09-01T02:12:03.284Z
authors: ["yush_g"]
type: posts
draft: true
slug: "zk"
category: "30 min read"
tags: ["crypto", "zk"]
description: "zk takes"
aliases:
  - /posts/takes
  - /takes
math: true
---

When entering the ZK space, it's easy to be overwhelmed. Everyone is shilling their own protocol, and there are a ton of different proving standards and papers coming out every day. Folks often have similar questions on how to think about different ideas and protocols security, efficiency, and tradeoff wise. Unfortunately, its very hard to quickly distinguish what is worth investing into, and all of the precise security guarantees or undisclosed "gotchas". I will summarize how I am personally currently thinking about the space of ZK tech, especially as we make decisions for what to prioritize for our own code and protocols. I am not perfectly versed in all of the tradeoffs of all of the recent ideas, but this will be a live doc updated as I read and learn more, and folks comment corrections.

This is NOT an indictment of the ideas/protocols I don't highlight or cover favorably, nor does this represent the opinions of anyone I cite or credit (they are my interpretations only). I am aiming to make an intellectually honest survey, and so if I misunderstand something, please tell me ([telegram](https://t.me/yush_g), [twitter](https://twitter.com/yush_g)) -- I am very open to continual changes and improvements, especially as the space and this tech rapidly evolves.

## ZK Proving Languages and Stacks
Two thorough benchmarks for server-based ZK proof stacks are [Celer's benchmarking](https://blog.celer.network/2023/08/04/the-pantheon-of-zero-knowledge-proof-development-frameworks/) and [Modulus Labs' graphs](https://medium.com/@ModulusLabs/chapter-5-the-cost-of-intelligence-da26dbf93307). Together, they paint a very clear picture of the tradeoffs. I've summarized some here as well, and provide a conclusion at the end.
- Circom: This is the language that has historically been used by the main zk apps in production, including [Dark Forest](https://zkga.me) and Tornado Cash. It is commonly used because it has the fastest browser proving time due to optimized WASM proofs in the browser, super-fast server side proving via [rapidsnark](https://github.com/iden3/rapidsnark) which is only about [10% slower than gnark](https://blog.celer.network/2023/08/04/the-pantheon-of-zero-knowledge-proof-development-frameworks/), and extremely small and fast on-chain verification (8 uint256s verified in about ~300K gas). The language is relatively easy to pick up and experiment with (i.e. at [zkrepl.dev](https://zkrepl.dev)) and has a good developer community that has contributed a [significant number of circuits](https://github.com/iden3/circomlib/blob/master/circuits/). There's a number of backends including [Nova](https://github.com/nalinbhardwaj/Nova-Scotia), a very slow PLONK, and [STARKs](https://github.com/vimwitch/circom-stark).
- Halo2: This is the library originally developed by zcash for generating PLONKish ZK proofs, and currently maintained by PSE and built upon by Axiom and EZKL. It's currently basically the fastest client side prover for in browser applications, and has GPU-accelerated ([repo](https://github.com/DelphinusLab/halo2-gpu-specific)) [server-side recursive provers](https://github.com/axiom-crypto/snark-verifier/blob/c36ff8c18c46d9b36d0a780ccaaf88185cf333a7/Cargo.toml#L38), with [solidity verifiers](https://github.com/han0110/halo2_solidity_verifier) that make arbitrary proofs only [~450K gas onchain](https://demo.axiom.xyz/).
- plonky2/3: [Security is unclear](https://twitter.com/nibnalin/status/1626824962299527169) due to unproven-ness of novel things like grinding, but is quite fast on baremetal. Plonky2 has not been used in any client side applications yet, since browser-based implementations do not get their speed gains (which mostly come from field size being small enough to fit elements in single vectorized registers). However, in browser, vectorization in WASM is still pending standardization, so it'll be far slower. Thus we don't expect client side proofs to be that fast in browser, even though on baremetal macbook it completes pretty large proofs (100-1000 poseidon hashes?) in less than a second. Bonsai from risc0 also based on FRI shows similar benchmarks on metal, but has a similar WASM problem for client side privacy. Proofs are closer to 250kB which is a no-go for on-chain proofs, though Succinct is working on a WIP promising recursive verifier of 40M constraints for plonky2 without lookups.
- New Lookups: We have heard that many top companies are planning on migrating the default lookups to a LogUp-based scheme. In addition, Lasso/Jolt synthesizes existing advances well, and they point out accurately that small scalar MSMs do in fact lead to decent (but not the claimed 40x) efficiency gains. Their work has been reasonably criticized since its [not as novel as they imply](https://twitter.com/SuccinctJT/status/1691092769261920256) and their open source code is incomplete. I can see it inspiring great work in the future however, especially with the MSM observation!
- GKR/Sumcheck: This seems to perform very well in Modulus Labs' tests. It was a SNARK precursor from 2008 that has recently been combined with SNARK work to lead to some big speedups. Thaler has a [good breakdown](https://people.cs.georgetown.edu/jthaler/GKRNote.pdf) -- GKR and sumcheck is still very relevant, and in fact is one of the main advances that Lasso uses to beat the usual grand product argument.
- Noir: This is an experimental new compiler by Aztec, that claims to compile a higher level language into any number of backends. This isn't actually a big gain over circom, as circom has [Nova](https://github.com/nalinbhardwaj/Nova-Scotia), a very slow PLONK, and [STARKs](https://github.com/vimwitch/circom-stark) as well even though it wasn't built for them, but Noir is much more limited. Unfortunately, in our experience circuits also take 50x randomly longer to prove (i.e. ~6 minutes to prove browser-side in Circom, take about ~4 hours in Noir). For concrete benchmarks, see Richard's [RSA circuit](https://github.com/SetProtocol/noir-rsa/actions/runs/6055065654). It's unclear why Noir is so unusable, theoretically they are working on it.
- Nova: Folding schemes based on Nova are by far the fastest client-side provers due to parallelizable recursion. Projects including Nova Scotia have made this very accessible to developers, but [direct on-chain verification](https://github.com/jbaylina/nova-circom-verifier) needs a 8-10 million constraint proof server-side right now, which is actually probably sub-10 seconds. Nexus from Dan Boneh's lab claims to have optimized and accelerated Microsoft's implementation and claim benchmarks are coming in September.
- Spartan: Lets you do right-field arithmetic on ECDSA because it supports more elliptic curves, so [spartan-ecdsa](https://personaelabs.org/posts/spartan-ecdsa/) is both fast and performant. Circuits are harder to write and there isn't much tooling, but for just proof of Ethereum signatures, this is pretty good.

In conclusion, for writing a new circuit of your own we recommend:
- circom for tiny client side proofs (i.e. hashing) or server-side proofs where privacy is less critical. Best tooling, lectures to learn ([more general](https://zkiap.com), [circom-specific](https://learn.0xparc.org/circom)), ease of switching to Nova/STARKs, and library of existing circuits.
- halo2 for client-side fast proofs where privacy is critical (performant/on-chain proofs require a beefy recursive server). Has a growing library of existing circuits as well as [accessible lectures and exercises to learn](https://learn.0xparc.org/halo2).
- plonky2/3 for ultra-fast server side proofs where privacy is irrelevant. Best for things like ZK EVMs.

I generally drink my own Kool-Aid, so we have used this logic to prioritize what to put into production for [zk email](https://github.com/zkemail/) -- in practice, we haven't really regretted it.

More bespoke systems may be marginally faster, but harder to learn and you may have to build more core circuit logic yourself. There are many, many other proof systems that I haven't mentioned nor gotten time to look at (Lurk, Kimchi/Pickles, etc) -- until they are more mainstream, many of the core primitives (big int, signatures, all the hashing algorithms, etc) are likely still being built out for them so they are not high priority for us to explore. I am open to seeing fair, comparative benchmarks for such proof systems on these common operations however, and adding them to this list!

## ZK Ecosystems
This landscape has a [great breakdown](https://flyingnobita.com/posts/2022/11/27/zkp-landscape) of what all of the different provers are doing.
- Ethereum: constantly has a high ethos of working in public, novel ideas, critical public-goods aligned ideological drive, [and consistently intellectual honest technical direction](https://vitalik.ca/). Thusly attracts an [extremely high quality of publicly discussed open source protocol and cryptography research](https://ethresear.ch/), and basically every other chain is playing catch up. Cost per proof will plummet over time as L2s and ZKEVMs reach production.
- [Risc0](https://dev.risczero.com/): Uses a custom implementation of STARKs (FRI) to prove RISC-V instruction set directly from Rust. STARKs inherently have larger proof sizes (see their [datasheet](https://dev.risczero.com/datasheet.pdf)) (~250 kB) which makes these hard to verify on-chain (calldata alone would cost 16M gas) but pretty quick to generate (seconds on consumer hardware, less on their cloud cluster). As this becomes more efficient i.e. via better lookup algorithms, I hope it becomes the de-facto way that servers prove they are executing the correct open source code. They have a pretty insane 100 GPU cluster for fast, non-private proving. It would actually be pretty cool to publicly verify all Rust server executions via this protocol, and their new thing [Bonsai](https://dev.risczero.com/bonsai/) with infra for on-chain calls of arbitrary programs is a pretty interesting model. In general, because of the overhead from not having bespoke circuits, it will be much slower than rolling your own circuits and isn't practical in browser for the same aforementioned reasons as small field FRI protocols, but we are excited to see how it evolves.
- Starkware/Cairo: Has weird licensing with Polaris. All the good teams I know building on it (i.e. Modulus Labs) left due to poor tooling and poor scaling, and I know other teams for which dealing with the verifier is a bottleneck to their shipping velocity. They claim transpilation can make it compatible with Solidity, but making this process auditable seems near impossible so it is hard to trust (not their fault, mostly inherent with the decision to use a new language). Regardless, they were the first in the STARK space and made insane tech breakthroughs and speed benchmarks as well as a great attempt to be like Rust syntax, for which I commend their approach. RWith the newly open source prover, I'm curious to see if usage will increase.

I think it's clear that on-chain apps should be built in the Ethereum ecosystem for the time being -- we expect more things to be EVM compatible over time so this will be a good bet regardless. Other nascent zk ecosystems include Aztec, Mina, and Miden, but they inherently have less developers and ecosystem activity. I am excited to see results, benchmarks, and progress from these teams, as they all have commendable and ambitious goals.